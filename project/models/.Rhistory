geom_line(aes(lambda, prior.NBA), col = "red") +
geom_line(aes(lambda, lik.NBA), col = "red") +
geom_line(aes(lambda, post.NBA), col = "red")
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA) * 0.01),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC) * 0.01)
)
df
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA)),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC))
)
ggplot(df) +
geom_line(aes(lambda, prior.NBA), col = "red") +
geom_line(aes(lambda, lik.NBA), col = "red") +
geom_line(aes(lambda, post.NBA), col = "red")
ggplot(df) +
geom_line(aes(lambda, prior.NBA), col = "red") +
geom_line(aes(lambda, lik.NBA), col = "blue") +
geom_line(aes(lambda, post.NBA), col = "green")
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA) * 0.01),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC))
)
ggplot(df) +
geom_line(aes(lambda, prior.NBA), col = "red") +
geom_line(aes(lambda, lik.NBA), col = "blue") +
geom_line(aes(lambda, post.NBA), col = "green")
ggplot(df) +
geom_line(aes(lambda, prior.NBA), col = "red") +
geom_line(aes(lambda, lik.NBA), col = "blue")
lik.NBA <- lik.NBA / (sum(lik.NBA) * 0.01)
data <- read.table("./basquet.txt")
data.NBA <- as.numeric(data[-1,2])
data.ABC <- as.numeric(data[-1,1])
lambda <- seq(130, 270, 0.01)
lik.NBA <- map_dbl(lambda, ~ prod(dpois(data.NBA, .x)))
lik.ABC <- map_dbl(lambda, ~ prod(dpois(data.ABC, .x)))
lik.NBA <- lik.NBA / (sum(lik.NBA) * 0.01)
df <- tibble(lambda, lik.NBA, lik.ABC)
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA) * 0.01),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC))
)
ggplot(df) +
geom_line(aes(lambda, prior.NBA), col = "red") +
geom_line(aes(lambda, lik.NBA), col = "blue") +
geom_line(aes(lambda, post.NBA), col = "green")
df %>%
gather(key = Distribution, value = value, -lambda) %>%
ggplot() +
geom_line(aes(x = lambda, y = value, col = Distribution))
sum(lik.ABC)
sum(lik.NBA)
sum(data.NBA)
sum(data.ABC)
sum(lik.NBA)
sum(lik.ABC)
lik.NBA <- map_dbl(lambda, ~ prod(dpois(data.NBA, .x)))
lik.ABC <- map_dbl(lambda, ~ prod(dpois(data.ABC, .x)))
sum(lik.NBA)
sum(lik.ABC)
lik.NBA <- lik.NBA / (sum(lik.NBA) * 0.01)
lik.ABC <- lik.ABC / (sum(lik.ABC) * 0.01)
sum(lik.NBA)
sum(lik.ABC)
data <- read.table("./basquet.txt")
data.NBA <- as.numeric(data[-1,2])
data.ABC <- as.numeric(data[-1,1])
lambda <- seq(130, 270, 0.01)
lik.NBA <- map_dbl(lambda, ~ prod(dpois(data.NBA, .x)))
lik.ABC <- map_dbl(lambda, ~ prod(dpois(data.ABC, .x)))
lik.NBA <- lik.NBA / (sum(lik.NBA) * 0.01)
lik.ABC <- lik.ABC / (sum(lik.ABC) * 0.01)
df <- tibble(lambda, lik.NBA, lik.ABC)
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA) * 0.01),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC) * 0.01)
)
df %>%
gather(key = Distribution, value = value, -lambda) %>%
ggplot() +
geom_line(aes(x = lambda, y = value, col = Distribution))
?dnbinom
n <- length(data.ABC[-1,1])
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
prior.NBA <- c(500, 2.5)
prior.ABC <- c(425, 2.5)
data <- read.table("./basquet.txt")
data.NBA <- as.numeric(data[-1,2])
data.ABC <- as.numeric(data[-1,1])
lambda <- seq(130, 270, 0.01)
lik.NBA <- map_dbl(lambda, ~ prod(dpois(data.NBA, .x)))
lik.ABC <- map_dbl(lambda, ~ prod(dpois(data.ABC, .x)))
lik.NBA <- lik.NBA / (sum(lik.NBA) * 0.01)
lik.ABC <- lik.ABC / (sum(lik.ABC) * 0.01)
df <- tibble(lambda, lik.NBA, lik.ABC)
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA) * 0.01),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC) * 0.01)
)
df %>%
gather(key = Distribution, value = value, -lambda) %>%
ggplot() +
geom_line(aes(x = lambda, y = value, col = Distribution))
M <- 10000  # Number of simulations
n <- length(data.ABC[-1,1])
n <- length(data.ABC)
mean(y.sim)
post.NBA <- c(prior.NBA[1] + sum(data.NBA), prior.NBA[2] + length(data.NBA))
post.ABC <- c(prior.ABC[1] + sum(data.ABC), prior.ABC[2] + length(data.ABC))
y.sim <- rpois(M, post.NBA) - rpois(M, post.ABC)
mean(y.sim)
y.sim
post.NBA
lam.post.NBA <- rgamma(M, shape = post.NBA[1], rate = post.NBA[2])
lam.post.ABC <- rgamma(M, shape = post.ABC[1], rate = post.ABC[2])
y.sim <- rpois(M, lam.post.NBA) - rpois(M, lam.post.ABC)
post.NBA <- c(prior.NBA[1] + sum(data.NBA), prior.NBA[2] + length(data.NBA))
post.ABC <- c(prior.ABC[1] + sum(data.ABC), prior.ABC[2] + length(data.ABC))
lam.post.NBA <- rgamma(M, shape = post.NBA[1], rate = post.NBA[2])
lam.post.ABC <- rgamma(M, shape = post.ABC[1], rate = post.ABC[2])
y.sim <- rpois(M, lam.post.NBA) - rpois(M, lam.post.ABC)
mean(y.sim)
length(y.sim > 0)
length(y.sim > 0)
y.sim
y.sim[y.sim > 0]
length(y.sim[y.sim > 0])
# Probability that NBA match has more points than ABC match
length(y.sim[y.sim > 0]) / M
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
prior.NBA <- c(500, 2.5)
prior.ABC <- c(425, 2.5)
data <- read.table("./basquet.txt")
data.NBA <- as.numeric(data[-1,2])
data.ABC <- as.numeric(data[-1,1])
lambda <- seq(130, 270, 0.01)
lik.NBA <- map_dbl(lambda, ~ prod(dpois(data.NBA, .x)))
lik.ABC <- map_dbl(lambda, ~ prod(dpois(data.ABC, .x)))
lik.NBA <- lik.NBA / (sum(lik.NBA) * 0.01)
lik.ABC <- lik.ABC / (sum(lik.ABC) * 0.01)
df <- tibble(lambda, lik.NBA, lik.ABC)
df <- df %>%
mutate(
prior.NBA = dgamma(lambda, shape = prior.NBA[1], rate = prior.NBA[2]),
prior.ABC = dgamma(lambda, shape = prior.ABC[1], rate = prior.ABC[2]),
post.NBA = prior.NBA * lik.NBA / (sum(prior.NBA * lik.NBA) * 0.01),
post.ABC = prior.ABC * lik.ABC / (sum(prior.ABC * lik.ABC) * 0.01)
)
df %>%
gather(key = Distribution, value = value, -lambda) %>%
ggplot() +
geom_line(aes(x = lambda, y = value, col = Distribution))
M <- 10000  # Number of simulations
set.seed(666)
post.NBA <- c(prior.NBA[1] + sum(data.NBA), prior.NBA[2] + length(data.NBA))
post.ABC <- c(prior.ABC[1] + sum(data.ABC), prior.ABC[2] + length(data.ABC))
lam.post.NBA <- rgamma(M, shape = post.NBA[1], rate = post.NBA[2])
lam.post.ABC <- rgamma(M, shape = post.ABC[1], rate = post.ABC[2])
y.sim <- rpois(M, lam.post.NBA) - rpois(M, lam.post.ABC)
# Probability that NBA match has more points than ABC match
length(y.sim[y.sim > 0]) / M
length(y.sim[y.sim >= 0]) / M
length(y.sim[y.sim >= 60]) / M
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(rstan)
library(bayesplot)
options(mc.cores = parallel::detectCores())
Y_A <- c(115, 120, 111, 123, 116,
121, 118, 116, 127, 129)
Y_B <- c(123, 131, 113, 119, 123,
113, 128, 126, 125, 128)
data = list(n_A = length(Y_A), n_B = length(Y_B),
Y_A = Y_A, Y_B = Y_B)
fit <- stan("./stan_model/training_workers.stan", iter = 1000, chains = 4,
data = data)
fit
posterior <- as.matrix(fit)
mu_A_post <- posterior[,"mu_A"]
mu_B_post <- posterior[,"mu_B"]
acf(mu_A_post)
acf(mu_B_post)
traceplot(fit)
plot(density(mu_A_post))
plot(density(mu_B_post))
plot_title <- ggtitle("Posterior distributions of mu_A and mu_B", "with medians and 80% intervals")
mcmc_areas(posterior,
pars = c("mu_A", "mu_B"),
prob = 0.8) + plot_title
mcmc_trace(posterior,
pars = c("mu_A", "mu_B"),
facet_args = list(nrow = 2))
diff <- mu_A_post - mu_B_post
plot(density(diff))
plot(density(posterior[,"diff"]))
quantile(diff)
?quantile
quantile(diff, c(0.025, 0.975))
quantile(posterior[,"diff"], c(0.025, 0.975))
quantile(posterior[,"diff"], c(0.025, 0.975))
plot(density(posterior[,"diff"]))
quantile(posterior[,"diff"], c(0.025, 0.975))
plot(density(posterior[,"diff"]))
mcmc_trace(posterior,
pars = c("mu_A", "mu_B"),
facet_args = list(nrow = 2))
mcmc_areas(posterior,
pars = c("mu_A", "mu_B"),
prob = 0.8) + plot_title
mcmc_areas(posterior,
pars = c("diff"),
prob = 0.8) + plot_title
mcmc_areas(posterior,
pars = c("diff"),
prob = c(0.025, 0.975)) + plot_title
mcmc_areas(posterior,
pars = c("diff"),
prob = c(0.25, 0.975)) + plot_title
mcmc_areas(posterior,
mcmc_areas(posterior,
mcmc_areas(posterior,
pars = c("diff"),
prob = 0.95) + plot_title
)
}
mcmc_areas(posterior,
pars = c("diff"),
prob = 0.95) + plot_title
plot_title <- ggtitle("Posterior distributions of mu_A - mu_B", "with median and 95% credible interval")
mcmc_areas(posterior,
pars = c("diff"),
prob = 0.95) + plot_title
quantile(posterior[,"diff"], c(0.025, 0.975))
plot_title <- ggtitle("Posterior distributions of mu_A - mu_B", "with median and 95% credible interval")
mcmc_areas(posterior,
pars = c("diff"),
prob = 0.95) + plot_title
quantile(posterior[,"diff"], c(0.025, 0.975))
plot_title <- ggtitle("Posterior distributions of mu_A - mu_B", "with median and 95% credible interval")
mcmc_areas(posterior,
pars = c("diff"),
prob = 0.95) + plot_title
install.packages("stringi")
gam <- rgamma(1000, 1, rate = 1)
plot(gam)
hist(gam)
gam <- rgamma(1000, 5, rate = 1)
hist(gam)
hist(gam)
?dgamma
1:10:0.1
knitr::opts_chunk$set(echo = TRUE)
plot(function(x)dgamma(x,shape=6,rate=1))
plot(function(x)dgamma(x,shape=6,rate=1),xlim=c(0,10))
plot(function(x)dgamma(x,shape=6,rate=5),xlim=c(0,20))
plot(function(x)dgamma(x,shape=6,rate=0.01),xlim=c(0,20))
plot(function(x)dgamma(x,shape=100,rate=20),xlim=c(0,20))
plot(function(x)dgamma(x,shape=1,rate=0.2),xlim=c(0,20))
plot(function(x)dgamma(x,shape=10,rate=2),xlim=c(0,20))
plot(function(x)dgamma(x,shape=5,rate=1),xlim=c(0,20))
plot(function(x)dgamma(x,shape=5,rate=1),xlim=c(0,20))
plot(function(x)dgamma(x,shape=1,rate=0.1),xlim=c(0,20))
plot(function(x)dgamma(x,shape=2,rate=0.1),xlim=c(0,20))
plot(function(x)dgamma(x,shape=2,rate=0.2),xlim=c(0,20))
plot(function(x)dgamma(x,shape=2,rate=0.3),xlim=c(0,20))
plot(function(x)dgamma(x,shape=2,rate=0.33),xlim=c(0,20))
?rstan
library(rstan)
?rstan
library(rstan)
library(bayesplot)
library(tidyverse)
setwd("~/Documents/colab/bayesian/project/models")
library(rstan)
library(bayesplot)
library(tidyverse)
library(Hmisc)
library(ggplot2)
library(xtable)
set.seed(1234)
# Read the data that was cleaned in "erasmus.R".
data <- read.csv("../cleaned.csv")
summary(data)
dim(data)
# Change the data types again.
data <- data %>% transmute(duration = as.numeric(duration),
age = as.numeric(age),
gender = as.factor(gender),
nationality = as.factor(nationality),
sending.country = as.factor(sending.country),
receiving.country = as.factor(receiving.country),
activity = as.factor(activity),
participants = participants)
describe(data)
# We want to model the duration of the student exchange.
dur <- data$duration
any(is.na(dur)) # Checking to be sure that there are no NA here.
points <- 500
data_list <- list(
n=points,
y=sample(dur, size = points) # Sample `points` number of points from the dataset.
)
fit1 <- stan("../stan_models/model3.stan", iter = 1000, chains = 4,
data = data_list, seed = 1)
fit1 <- stan("../stan_models/model3.stan", iter = 1000, chains = 4,
data = data_list, seed = 1)
# Convergence analysis.
print(fit1)
traceplot(fit1)
points <- 5000
data_list <- list(
n=points,
y=sample(dur, size = points) # Sample `points` number of points from the dataset.
)
fit1 <- stan("../stan_models/model3.stan", iter = 1000, chains = 4,
data = data_list, seed = 1)
# Convergence analysis.
print(fit1)
traceplot(fit1)
# Lag en ok LaTeX tabell!
xtable(summary(fit1)$summary)
# Annen måte å plotte chainsene på.
# https://mc-stan.org/users/documentation/case-studies/identifying_mixture_models.html
# Lånt fra lenken: kan være grei å bruke for å sjekke at alt er greit underveis også!
chains1 <- as.data.frame(rstan::extract(fit1, permuted=FALSE)[,1,])
chains2 <- as.data.frame(rstan::extract(fit1, permuted=FALSE)[,2,])
chains3 <- as.data.frame(rstan::extract(fit1, permuted=FALSE)[,3,])
chains4 <- as.data.frame(rstan::extract(fit1, permuted=FALSE)[,4,])
par(mar = c(4, 4, 1.5, 1))
plot(chains1$mu1, chains1$mu2, col="black", pch=16, cex=0.8,
xlab="mu1", ylab="mu2", xlim = c(130, 140), ylim = c(270, 300),
main = "Chains for mu1 and mu2 Plotted in Two Dimensions")
points(chains2$mu1, chains2$mu2, col="red", pch=16, cex=0.8, alpha = 0.5)
points(chains3$mu1, chains3$mu2, col="yellow", pch=16, cex=0.8, alpha = 0.4)
points(chains4$mu1, chains4$mu2, col="blue", pch=16, cex=0.8, alpha = 0.3)
#lines(0.08*(1:100) - 4, 0.08*(1:100) - 4, col="grey", lw=2)
legend("topright", c("Chain 1", "Chain 2", "Chain 3", "Chain 4"),
fill=c("black", "red",
"yellow", "blue"), box.lty=0, inset=0.0005)
posterior <- as.data.frame(fit1)
head(posterior)
dim(posterior)
####### Model Checking
# Calculate the Posterior Predictive Distribution (Det stemmer vel dette?)
p.mean <- mean(posterior$p)
mu1.mean <- mean(posterior$mu1)
mu2.mean <- mean(posterior$mu2)
sigma.mean <- mean(posterior$sigma)
sigma1.mean <- mean(posterior$sigma1)
sigma2.mean <- mean(posterior$sigma2)
N <- 10000
components <- sample(1:2,prob=c(p.mean,1-p.mean),size=N,replace=TRUE)
mus <- c(mu1.mean,mu2.mean)
sds <- c(sigma1.mean,sigma2.mean)
samples <- rnorm(N)*sds[components]+mus[components]
tibble(samples) %>%
ggplot(aes(samples)) +
geom_density(aes(y = (..count..)/sum(..count..))) +
ggtitle("Mix of Gaussian")
ggsave("../626fca86090ba51a6aff419a/plots/postpred3.pdf", width = 7, height = 5)
# Usikker på om denne er normalisert (slik at det er en density)
# eller om den som er plottet ovenfor er det?!
d <- density(samples, n = N)
plot(d)
n <- 10000
# We select the statistics 1st quart, median and 3rd quart.
statistic.distrs <- list(first = rep(NA, n), median = rep(NA, n), third = rep(NA, n))
for(i in 1:n){
# Simulate the posterior distribution.
components <- sample(1:2,prob=c(p.mean,1-p.mean),size=N,replace=TRUE)
mus <- c(mu1.mean,mu2.mean)
sds <- c(sigma.mean,sigma.mean)
samples <- rnorm(N)*sds[components]+mus[components]
# Simulate from the posterior distribution.
q <- quantile(samples, c(0.25, 0.5, 0.75))
statistic.distrs$first[i] <- q[1]
statistic.distrs$median[i] <- q[2]
statistic.distrs$third[i] <- q[3]
}
for(i in 1:n){
# Simulate the posterior distribution.
components <- sample(1:2,prob=c(p.mean,1-p.mean),size=N,replace=TRUE)
mus <- c(mu1.mean,mu2.mean)
sds <- c(sigma1.mean,sigma2.mean)
samples <- rnorm(N)*sds[components]+mus[components]
# Simulate from the posterior distribution.
q <- quantile(samples, c(0.25, 0.5, 0.75))
statistic.distrs$first[i] <- q[1]
statistic.distrs$median[i] <- q[2]
statistic.distrs$third[i] <- q[3]
}
# Compare with the same statistics in the data.
q.data <- quantile(dur, c(0.25, 0.5, 0.75))
# Plot shows that the first quartile in the data is highly unlikely in the reference distribution.
# Perhaps not a good model then!
tibble(statistic.distrs$first) %>%
ggplot(aes(statistic.distrs$first)) +
geom_density(aes(y = (..count..)/sum(..count..))) +
ggtitle("First Quartile") +
geom_vline(xintercept = q.data[1])
# Also did numerical calculation.
min(mean(statistic.distrs$first < q.data[1]), mean(statistic.distrs$first > q.data[1]))
# Plot shows that median is highly unlikely.
tibble(statistic.distrs$median) %>%
ggplot(aes(statistic.distrs$median)) +
geom_density(aes(y = (..count..)/sum(..count..))) +
ggtitle("Median") +
geom_vline(xintercept = q.data[2])
# Also did numerical calculation.
min(mean(statistic.distrs$median < q.data[2]), mean(statistic.distrs$median > q.data[2]))
# Plot shows that third quartile is highly unlikely.
# Model is not good according to any of these three statistics.
tibble(statistic.distrs$third) %>%
ggplot(aes(statistic.distrs$third)) +
geom_density(aes(y = (..count..)/sum(..count..))) +
ggtitle("Third Quartile") +
geom_vline(xintercept = q.data[3])
# Also did numerical calculation.
min(mean(statistic.distrs$third < q.data[3]), mean(statistic.distrs$third > q.data[3]))
library(rstan)
library(bayesplot)
library(tidyverse)
library(Hmisc)
library(ggplot2)
library(xtable)
set.seed(1234)
# Read the data that was cleaned in "erasmus.R".
data <- read.csv("../cleaned.csv")
summary(data)
dim(data)
# Change the data types again.
data <- data %>% transmute(duration = as.numeric(duration),
age = as.numeric(age),
gender = as.factor(gender),
nationality = as.factor(nationality),
sending.country = as.factor(sending.country),
receiving.country = as.factor(receiving.country),
activity = as.factor(activity),
participants = participants)
describe(data)
# We want to model the duration of the student exchange.
dur <- data$duration
any(is.na(dur)) # Checking to be sure that there are no NA here.
describe(data)
# Omit the unknown genders for our regression model
data <- data %>% filter(gender = "Female" | gender ="Male")
# Omit the unknown genders for our regression model
data <- data %>% filter(gender == "Female" | gender == "Male")
describe(data)
?refactor
library(dplyr)
?refactor
?recode
summary(data)
data$gender <- as.integer(data$gender)
summary(data)
describe(data)
data$gender <- as.integer(data$gender) - 1
describe(data)
data_list <- c(dur, age, gender)
set.seed(1234)
# Read the data that was cleaned in "erasmus.R".
data <- read.csv("../cleaned.csv")
summary(data)
dim(data)
# Change the data types again.
data <- data %>% transmute(duration = as.numeric(duration),
age = as.numeric(age),
gender = as.factor(gender),
nationality = as.factor(nationality),
sending.country = as.factor(sending.country),
receiving.country = as.factor(receiving.country),
activity = as.factor(activity),
participants = participants)
describe(data)
# Omit the unknown genders for our regression model
data <- data %>% filter(gender == "Female" | gender == "Male")
summary(data)
data$gender <- as.integer(data$gender) - 1
summary(data)
data$gender <- as.integer(data$gender) - 1
describe(data)
points <- 500
data_sample <- sample(data_list, points)
